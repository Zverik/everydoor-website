{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Every Door","text":"<p>The best OpenStreetMap editor for POIs and entrances.</p>"},{"location":"#get-the-app","title":"Get The App","text":""},{"location":"#features","title":"Features","text":"<ul> <li>100% OpenStreetMap editor with no dependencies on third-party endpoints.</li> <li>See all the shops and amenities nearby, without geospatial displacement.</li> <li>Engage the <code>check_date</code> tag to confirm shops' existence.</li> <li>Edit buildings and add entrances with apartment numbers.</li> <li>Map every manhole, bench, and street lamp in the micro-mapping mode.</li> <li>Pre-load imagery tiles and work offline.</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Source Code @GitHub</li> <li>Translations @Weblate</li> <li>Telegram Group (rus)</li> <li>Privacy Policy</li> </ul>"},{"location":"#stay-connected","title":"Stay Connected","text":"<ul> <li>Mastodon</li> <li>Twitter</li> </ul> <p>Ilja Zverev Tallinn, Estonia</p> <p>ilya@zverev.info</p>"},{"location":"#please-help","title":"Please Help!","text":"<p>This page looks bare-bones. I would really love to improve its design. Please mail me or create a pull request!</p>"},{"location":"privacy_policy/","title":"Privacy Policy","text":""},{"location":"privacy_policy/#you-upload-to-openstreetmap","title":"You Upload To OpenStreetMap","text":"<p>With this app you make actual and direct contributions to OpenStreetMap. There is no third party in-between the app and OSM infrastructure.</p> <p>Editing OpenStreetMap anonymously is not possible. Any changes you make (and their date and location) are attributed to your OSM user account and publicly visible on the openstreetmap.org website. Because Every Door should only be used for on-site survey, this reveals where and when you have used the app.</p>"},{"location":"privacy_policy/#location","title":"Location","text":"<p>The app does not share your GPS location with anyone. It is used to focus the map around your location, optionally downloading map tiles. </p>"},{"location":"privacy_policy/#contact-me","title":"Contact Me","text":"<p>If you have any questions, ask Ilya, the author.</p> <p>Portions of this text were adapted from StreetComplete's statement.</p>"},{"location":"develop/","title":"Contributor's Guide","text":"<p>Every Door needs your help!</p> <p>There are multiple ways you can contribute. The main one being, take the app and go outside to map! Walk around a shopping district, map everything at a playground, bike into a forest and try drawing forest paths. That's the best way to test everything the app has to offer, and also gain ideas on how it may help you better.</p> <p>Other that that,.. everything still. Starting with the icon: imperfect, sketchy, like the app itself. Maybe it's time to become more serious? Same with this website: the landing page needs to be more inviting. And maybe in more languages than one.</p> <p>And code. The road map has like a hundred items on it, and people are always asking for more. Look into plugins, and if they don't cover what you want, try cloning the repository, learning Dart and Flutter, and improving the app.</p> <p>This section guides you around all the ways you can contribute.</p> <ul> <li>How to report bugs and request features</li> <li>Translating the app, presets, and everything</li> <li>Adding more presets and fields</li> <li>General design principles</li> <li>Downloading the code and setting up an IDE</li> <li>Navigate yourself around the code</li> <li>Guidelines on hacking specific things</li> </ul>"},{"location":"develop/bugs/","title":"Bugs and Wishes","text":"<p>Every Door issues are collected and processed on Github. In order to submit or comment a report, you need to register and login. Just press \"New Issue\" and fill in the form.</p> <p>Mind the application part you're reporting about:</p> <ul> <li>If it's about an object type or fields on the editing panel, that is most likely about presets.   See the presets page about contributing.</li> <li>If something is wrong with a map layer underneath markers, you mind need to contact   OSM-Carto map layer developers.</li> <li>If translations are incorrect, you most likely know how to improve them.   This guide will help you.</li> </ul> <p>Before reporting, first open Settings (the three-line button at the top left) \u2192 About Every Door. Make sure the version is the latest one available in app stores for your platform.</p> <p>Also, try disabling all plugins (Settings \u2192\u00a0Plugins). If it helps, please report a plugin issue.</p>"},{"location":"develop/bugs/#best-practices","title":"Best Practices","text":"<p>When reporting an issue, please provide as much information as possible. It would help if you include:</p> <ul> <li>Every Door version, platform, and from where you got the app.</li> <li>What you expected, and what you got instead. Possibly with reasons for your expectations.</li> <li>Relevant parts, or an entire system log, available in Settings \u2192 About \u2192 System Log.</li> <li>A screenshot or two.</li> </ul> <p>Please do not be intimidated with the list: often the bug is pretty straighforward and does not need many details to be triangulated. But the more details developers get, the better.</p> <p>One important thing is not to report multiple issues in a single ticket. Even if they are tiny. This helps developers be productive and mentally healthy. Opening multiple tickets is fine, please do not lump them into a single one.</p>"},{"location":"develop/bugs/#asking-for-features","title":"Asking for Features","text":"<p>Mapping varies from country to country, and it is entirely possible Every Door does not have a feature that is important for surveyors somewhere. Feature requests are welcome!</p> <p>With that, please take note of design principles. Every Door is not a general-purpose editor, and it cannot be everything. We have Vespucci and Go Map for that. So please be prepared to explain your request deeper, and for it to possibly be rejected. We do not close tickets without explanation, but sometimes it is impossible to cram everything into a single app.</p> <p>It is quite hard to determine how complex a feature is, so please be patient. Some features may take years to be implemented. The editor is developed in free time as a hobby project, so long development cycles are to be expected. Generally, the more fun or useful your request is, the eager developers are to work on it. Alas usefulness does not equate fun, and developers have a weird definition of \"fun\", so it's nearly impossible to predict. Sorry.</p> <p>You may try to create your feature as a plugin instead.</p>"},{"location":"develop/bugs/#road-map","title":"Road Map","text":"<p>Every Door development is tracked in this project. It's split by milestones (that is, versions). It is unlikely that your bug or a feature would get worked on if they are not assigned a milestone, or do not have any labels.</p> <p>The road map should not be taken as a firm list of features that will be released with the new app version. It mostly sorts tickets into priorities: which should be worked on now, and which could be postponed when maintainers have more time, or a developers comes eager to work on something.</p>"},{"location":"develop/bugs/#issues-with-websites","title":"Issues With Websites","text":"<p>This documentation website (which doubles as a landing page) is also maintained on Github. You technically can create issues there. Maybe I have missed something important in guides, so I'd be happy to be reminded. Obviously you can create a pull request instead.</p> <p>The plugin repository source code is here. It is pretty raw, so bugs are to be expected. Please create issues in that repo, not in Every Door's. Code is also welcome.</p>"},{"location":"develop/bugs/#plugin-issues","title":"Plugin Issues","text":"<p>Alas we cannot fix any issues with plugins, regardless of where they came from. One exception is when you are a plugin author, and the issue actually comes from Every Door. But that case has been outlined above.</p> <p>You have two options for reporting a plugin issue:</p> <ol> <li>On the plugin repository page for that plugin, there might be a link to the plugin     home page (which might be a Github repository). That page would direct you to means     of reporting issues.</li> <li>Since only OpenStreetMap users can upload plugins, the author's name there is actually     an OSM display name, for which you can search. Try writing them a private message     via the OSM website.</li> </ol> <p>As a last resort, you might try creating a topic on the OpenStreetMap community forum. Somebody might help you with your problem then. But alas no guarantees.</p>"},{"location":"develop/build/","title":"Development Environment","text":""},{"location":"develop/build/#installing-everything","title":"Installing Everything","text":"<p>Every Door is a Flutter app, and I cannot beat the conscise step-by-step setting up walkthrough on the Flutter website. Please follow it through.</p> <p>My IDE of choice is the standard Android Studio: it includes an Android emulator and all tools to build and package Android apps. On macOS it would make sense to use XCode instead. There's no point in downloading VSCode just to install Flutter: the alternative is just unzipping a file and adding the result to <code>PATH</code>.</p> <p>For small changes I use Vim with YouCompleteMe for LSP (see here) and dart-vim-plugin for formatting. Note that Dart LSP is huge and slow to load, so there isn't much memory benefit from using Vim over other IDEs.</p> <p>Also keep in mind when installing Flutter SDK that despite it being 2025, it is still risky using directories with spaces in them.</p>"},{"location":"develop/build/#building-every-door","title":"Building Every Door","text":"<p>First, clone the repository:</p> <pre><code>git clone https://github.com/Zverik/every_door.git\n</code></pre> <p>You can add <code>--recursive</code> if you plan on testing vendored Flutter SDK, but there's generally no need.</p> <p>Then you would need a preset database asset. For releases, it is downloaded. Put it in the <code>assets/</code> directory. For developing, the proper way would be to download taginfo-db.db and unpack it somewhere (it's ~9 GB). Then enter the <code>tools</code> directory and run:</p> <pre><code>./update.sh /path/to/taginfo.db\n</code></pre> <p>Now you need to create an language file <code>lib/l10n/app_zh.arb</code> with no content (<code>{}</code>), because Flutter i18n has problems with absent parent language packs:</p> <pre><code>echo '{}' &gt; lib/l10n/app_zh.arb\n</code></pre> <p>And you're all set! Open the project in your IDE and run it, or build it from console:</p> <pre><code>flutter pub get\ndart run build_runner build\nflutter build\nflutter run # if you have a phone connected or an emulator running\n</code></pre> <p>The <code>build_runner</code> step creates a <code>lib/commit_info.g.dart</code> file with a current git commit hash. You do not need to re-run it unless you're publishing an apk for others to test, and want them to copy the full version (which is located on the About pane).</p>"},{"location":"develop/build/#submitting-changes","title":"Submitting Changes","text":"<p>Before starting work on a large feature, please consult with design principles, or maybe contact Ilya. It would be a pity to leave a big pull request rejected because of a disagreement. Of course that hasn't happened yet, and we strive to accept all contributions.</p> <p>If you're looking for a task to work on, check the roadmap. Anything on it is a wanted feature or a bug fix. An assigned milestone means higher priority.</p> <p>Now, creating a pull request is pretty easy, you don't need to collect much data for it, unlike a bug report. If the change is visual, a screenshot or a video would be appreciated. Please keep changes to a minimum: e.g. don't reformat the entire code base. Note that we use the standard default Dart format rules.</p> <p>The one rule to have your changes merged is, please respond to comments and update your code accordingly. We would like you to do all the needed changes, not do that ourselves. Please rebase your branch onto <code>main</code> yourself if there are possible merge conflicts. Unless there are conceptual issues with a pull request, and if you keep replying, your work won't get lost, and you will be mentioned in a change log.</p> <p>It's possible maintaner(s) might forget about your pull requests. Please wait a few days and post a comment to your pull request to remind them. Every Door is a hobby project, and maintainers might be busy with their jobs or family. Help in reviewing other pull requests is appreciated!</p> <p>Every Door is licensed under the ISC License. You should make every effort to ensure you only submit patches which are unencumbered by conflicting intellectual property rights.</p>"},{"location":"develop/cases/","title":"How To Find Things","text":"<p>The size of the code might be daunting (it is for me, the author), so this section is intended to help with finding, where exactly to contribute when you want to change something.</p> <p>Note that the code is in a constant (but glacial) flux, so some of those might be possible to change with a plugin in the future.</p>"},{"location":"develop/cases/#editing-standard-fields","title":"Editing Standard Fields","text":"<p>As mentioned in the plugin docs, \"standard fields\" is a third group of fields that gets added on top of \"fields\" and \"more fields\" for every object in the editor panel. This chapter traces its addition, marking what and where can be improved.</p>"},{"location":"develop/cases/#osmchange","title":"OsmChange","text":"<p>First we must mention that the single most important class in the app is <code>OsmChange</code>. It defines a set of changes over the base <code>OsmElement</code> received from OpenStreetMap, and a few methods to manipulate an object. For example, it acts as a <code>Map&lt;String, String&gt;</code> for tags, but keeps the changes separate.</p> <p>It can calculate an age based on the <code>check_date</code> tag (but note that it's a bit inconsistent with the overridden values for the <code>amenity</code> mode). There are methods to confirm an object (<code>check()</code>) and to toggle its disused status. The one most important method that's used everywhere returns full tags in a map: <code>getFullTags()</code>. It is of course cached.</p>"},{"location":"develop/cases/#detecting-a-preset","title":"Detecting a Preset","text":"<p>Now, to learn whether we need to add and shuffle fields, we first need to detect a preset. Let's look at <code>PoiEditorPage</code>'s state. In the <code>initState()</code>, the <code>amenity</code> (the object we edit) is either copied or created anew, and <code>updatePreset()</code> is called. For an already existing object (or a newly created from an NSI preset), we call <code>getPresetForTags()</code> from a preset provider.</p> <p>That method has got a lot of steps: checking for empty tags and <code>amenity=fixme</code> tags, asks plugins for an answer. But the main step is running a huge SQL query against the local SQLite database, which through clever CTE and sorting returns the one result.</p> <p>Is it good to have a single big SQL query? Felt like a clever idea at the time, but now I'm not so sure. But this method gets called dozens of times per second in the micromapping mode, so this could be considered optimizing.</p>"},{"location":"develop/cases/#localization","title":"Localization","text":"<p>All presets and fields are translated, so we pass the current <code>Locale</code> to preset provider methods. The plugin subsystem too requires it \u2014 and that's basically it. App localization is handled by the intl package.</p> <p>Passing locales to SQL queries in the preset provider works relatively simple. We create a CTE for a <code>langs</code> table that contains two columns, language code and a rank, starting with 1. And we join the results with this table, ordered by the language rank. Since window functions do not work in some SQLite versions, we just query all the results and keep the first one for each preset or field.</p>"},{"location":"develop/cases/#querying-fields","title":"Querying Fields","text":"<p>After we have a preset, we call <code>getFields()</code> Initially a preset is returned with empty fields, because its name and title can be all we need (e.g. for the micromapping mode). But for the editor, we need the fields. And we do another SQL query to the presets database, querying the <code>fields</code> table with the list from the <code>preset_fields</code>.</p> <p>Besides checking for a location, sorting languages, and sorting into two lists (\"fields\" and \"more fields\", based on the <code>required</code> flag), it does two more things.</p> <p>First is building the combo options. While needed only for combo fields, it is a very resource-intensive operation, since it conflates three sources:</p> <ol> <li>Options listed in the field definition.</li> <li>Popular tag values from TagInfo.</li> <li>Popular tag values from all the downloaded data.</li> </ol> <p>The result is stored in a database table, to not do this again. But still, it is another database query, so make it four for cache misses.</p> <p>That's why the <code>getFields()</code> method implements its own in-memory caching. You can notice how long the first loading of the editor pane takes. That's because in the collapsed \"more fields\" section there are dozens of combo fields.</p> <p>Finally, the method calls the long <code>fieldFromJson</code> function from <code>field.dart</code>. It has some overrides for common keys, and for others, it uses the type. It is pretty straightforward. When you're adding a field, do not forget to create it twice in this file, in both functions.</p>"},{"location":"develop/cases/#built-in-fields","title":"Built-in Fields","text":"<p>For some OSM keys (not preset names, and not field types) there are specific classes instantiated in the <code>fieldFromJson()</code>. For example, <code>NamePresetField</code> for a name, or a <code>WebsiteField</code> for a website. Those provide unique experience in Every Door, often with shortcuts to edit tags faster, or set multiple tags at once considering the context.</p>"},{"location":"develop/cases/#postcode-and-opening-hours","title":"Postcode and Opening Hours","text":"<p>Note that field processing (this section, standard fields etc) happens only when the object \"needs address\". Which means, it's either an amenity, a building, or an address point.</p> <p>First thing, an opening hours field is added unconditionally. Things just tend to have those.</p> <p>Then, a postal code (zip code) field is added. It is partially a hack: the address field in the default presets includes everything, but is not used. Instead, a custom field is added in Every Door, but it does not set a postcode (because it's a building property, not an amenity's). But some mappers might need it. For buildings and address points it is added to the main fields list, for other objects \u2014\u00a0to the additional list.</p>"},{"location":"develop/cases/#standard-fields","title":"Standard Fields","text":"<p>An amenity is considered to need the full standard fields set when its preset mentions both <code>opening_hours</code> and <code>phone</code> anywhere. Otherwise a shorter list of just two fields is added, for an address and a floor.</p> <p>You can find the list of fields in <code>kStandardPoiFields</code>. Note that it is constant, not dependent on anything. Each field is constructed alike to the <code>getFields()</code> method: queried from the preset database, injected with combo options, and cached. Plugins of course contribute to the results.</p> <p>When we don't need the full set, but a preset mentions some fields from the list, they are moved to the standard fields section as well.</p>"},{"location":"develop/cases/#sorting-fields","title":"Sorting Fields","text":"<p>At this point, we have three lists of <code>PresetField</code> instances: pre-filled <code>stdFields</code>, and empty <code>fields</code> and <code>moreFields</code>. The <code>extractFields()</code> method copies field instances from the preset to the latter two lists.</p> <p>With two exceptions: first, the standard fields are obviously skipped. Second, any fields from the <code>moreFields</code> are moved to <code>fields</code> if their key is present on the object, or they have a matching prerequisite.</p> <p>After this we have all three list prepared, and can re-render the editor page, displaying them to the user.</p>"},{"location":"develop/cases/#zooming-out","title":"Zooming Out","text":"<p>Every Door uses flutter_map library for its mapping. Over the years it's been doing pretty complex things with it (but not \"going native\" complex). This section is mostly about providers and components: what happens when you change modes implicitly.</p>"},{"location":"develop/cases/#map-controllers","title":"Map Controllers","text":"<p>Flutter map instances report their state and can be controller via <code>MapController</code> objects. Note that when you use it for yourself, there are certain troubles you have to go through.</p> <p>When you use the <code>CustomMap</code> widget in Every Door code, for bi-directional conversation you would pass the <code>CustomMapController</code>, which gets connected to the internal fields of the widget. With it, you can:</p> <ul> <li>Access the <code>MapController</code> itself, so that you can access and affect the map state     from outer listeners.</li> <li>Access the <code>GlobalKey</code> for the <code>FlutterMap</code> widget. It is used once, for detecting     its geometry on the screen.</li> <li>Zoom the map to a list of locations. Useful for amenities and micromapping modes.</li> </ul> <p>In the <code>CustomMap</code> itself, there is a lengthy <code>MapEvent</code> listener. It only processes user-initiated events, and does this:</p> <ul> <li>After moving the map, it updates the center location in <code>effectiveLocationProvider</code>.</li> <li>After rotating, it updated the angle in <code>rotationProvider</code> (the value is commonly     used for <code>initialRotation</code> property of the <code>FlutterMap</code> constructor).</li> <li>During the map movement initiated by the user, it disables GPS tracking     (in <code>trackingProvider</code>), and updates the zoom level in <code>zoomProvider</code>.</li> </ul> <p>And when the <code>switchToNavigate</code> flag is set, it also controls the navigation mode switch.</p>"},{"location":"develop/cases/#modes-and-the-browser","title":"Modes and the Browser","text":""},{"location":"develop/cases/#interactivity","title":"Interactivity","text":"<p>Decisions on zoom levels and interactivity</p>"},{"location":"develop/cases/#uploading-to-openstreetmap","title":"Uploading to OpenStreetMap","text":"<p>This section traces what happens when a user taps the upload button, but does not explain the entire uploading algorithm: it's a bit too complex. It would be useful to you to understand how providers interact, and how the data is packaged.</p> <p>This section will be completed later.</p> <ol> <li>Nav panel, upload button</li> <li>Upload provider</li> <li>Locking</li> <li>Uploading OSM changes<ul> <li>Splitting changes</li> <li>Downloading data</li> <li>Uploading data</li> <li>Updating the inner storage</li> </ul> </li> <li>Uploading notes</li> <li>Uploading scribbles</li> <li>Notification</li> </ol>"},{"location":"develop/design/","title":"Design Principles","text":"<p>Every Door is a highly opinionated editor. Which means, it makes a lot of assumptions on behalf of the user, and pushes for a few optimized workflows. Core principles are described in the readme:</p> <ol> <li>ED displays and edits only tagged nodes and polygons represented with their centerpoints. No roads.</li> <li>ED focuses on surveying: adding and detailing things that you can see around you. Not map maintenance.</li> <li>Fewer buttons and menus: heuristic is preferable to a setting, and every button benefits the surveyor.</li> </ol> <p>Those principles can be circumvented with plugins, but they regulate the core experience.</p>"},{"location":"develop/design/#data-complexity","title":"Data Complexity","text":"<p>The first principle says: we're editing only points. There are multiple reasons for this:</p> <ol> <li>Easier to process data and relations between objects.</li> <li>The screen is small, editing geometry would complicate everything while being inferior to desktop editing (and we have Vespucci).</li> <li>We can customize markers for every goal, not so much lines and polygons.</li> </ol> <p>Not having geometry restricts what you can do. For example, no drawing building contours or setting addresses to enclosed amenities. No detecting nearest streets and no painting downloaded OpenStreetMap data. All you have from OSM is a <code>OsmElement</code> object that has a point location. That's by design.</p> <p>If you think that to be limiting, consider also options for circumventing that. Like, instead of tracing streets (from imagery), you have a free-form drawing in the Notes mode, less consequential and hence more freeing.</p> <p>OpenStreetMap data model is unfortunately too complex in regard to object interdependencies. Adding <code>way</code> and <code>relation</code> processing would require support for splitting, adjusting, straightening, and also correctly processing restriction and route relations. As a result, we would have the second Vespucci or Go Map, and that's not the goal.</p> <p>Instead, we are focusing on representation and hiding the data model. Users edit not nodes and tags, but buildings and shops. That's why we have multiple modes: while pedestrian crossings and building entrances are denoted by nodes in ways, they belong to totally different classes and need to be considered differently. We are thinking in terms, not what is possible to do, but what exactly and with which purpose a user wants to do something. And from that, we devise a user interface.</p>"},{"location":"develop/design/#screen-estate","title":"Screen Estate","text":"<p>Most phones are smaller than a computer screen. Actually, often we have a 5\" or 6\" rectangle. How do we fit an entire geospatial editor inside? QGIS has 74 buttons by default just on the toolbar. JOSM has ~40 on two, plus multiple side panels. iD looks lean: it only has 20 buttons and one permanent sidebar. That is too much context one has to keep in their head, and too much controls for a small screen.</p> <p>Every Door does not approach this as an excercise of hiding things behind other things. No infinitely deep menus like in OsmAnd, no buttons behind buttons like in OsmTracker. It's not a general purpose editor, and that allows us to shrink focus, to allow for less at any given time, and thus opening more of the screen to the task at hand.</p> <p>The third principle says, instead of a switch, just choose a state based on the context. Instead of a button, try finding an interaction that comes naturally and does not require an always-on control. If an interactive control is not used in ten minutes of hardcore mapping, it should go.</p> <p>That's why every new thing on the screen has to be properly thought out, maybe gaining extra functions and proving itself over months of field testing, before it goes into the app. It has to be useful for every user, not in specific circumstances. For everything else, we've got plugins.</p> <p>Note that some people use tablets or rotate their phones sideways. Are screen elements laid out effectively in the landscape orientation?</p>"},{"location":"develop/design/#flow","title":"Flow","text":"<p>Surveying should bring a mapper joy. They are walking around and with each tap on the screen, they are improving the map. Nothing should stay in the way, so those sessions last longer. The mapper is feeling productive, and the app supports and encourages them to map more.</p> <p>That is the flow, and StreetComplete would be the best example of riding it. No hard choices, no mode switching, just an unending series of questions and answers. On the other end would be general purpose mobile editors with the constant \"wait what did I just press\" feeling.</p> <p>Every Door strives to be the most effective editor, allowing to collect one shop per minute, with all the details, or survey a village for addresses from a moving car. Nothing should stand in the way or slow the mapper down. Like:</p> <ul> <li>an important field too far down the form.</li> <li>a list of options too long to scroll.</li> <li>the mode sometimes wrong, making you consider the state.</li> <li>a common action inaccessible for non-obvious reason.</li> </ul> <p>Those are all issues I have encountered with Every Door, and we need to have less of those, not add to the list. Everything should be \"at the fingertips\", lowering the time a mapper stares at the screen in favor of walking around and finding more things to map.</p>"},{"location":"develop/presets/","title":"Developing Presets","text":"<p>TL;DR:</p> <ul> <li>Presets: repository, schema, mind the <code>fields</code>.</li> <li>Fields: repository, schema, consider <code>strings/options</code> for combos.</li> <li>Brand Suggestions: repository and wiki.</li> <li>Local: see presets in plugins.</li> </ul>"},{"location":"develop/presets/#global-presets","title":"Global Presets","text":"<p>The editor uses presets from iD. If you find something missing: an object type, a field in an editing form \u2014 you should take it upstream, to that repository, preferably in form of a pull request. This does sound complex, and this page would help you through it.</p> <p>You would benefit from keeping the preset schema at hand: it documents everything that goes into preset and field definitions.</p>"},{"location":"develop/presets/#presets","title":"Presets","text":"<p>A preset is a named set of fixed and editable tags. For example, the amenity/bench preset defines the fixed <code>amenity=bench</code> tag \u2014\u00a0that's how an object is deemed to be a bench. Every Door uses those fixed tags to split objects by types in the micromapping mode, and of course to get a list of fields for the editor.</p> <p></p> <p>Lists <code>fields</code> and <code>moreFields</code> define editable tags, split by importance (which usually depends on usage frequency). Those reference fields by names. It is important to have as few fields in the first list as possible \u2014 but also every field that can be quickly assessed and provides useful, practical information.</p> <p>Finally, a preset needs to be searchable. When a mapper sees a fish shop, they would most likely search for \"fish\", and it doesn't matter that the OSM tag is <code>shop=seafood</code>. That's why the preset includes an alias starting with \"fish\": search engines look at <code>name</code>, <code>aliases</code>, and <code>terms</code> properties, including their translations.</p> <p>That's basically it. Try looking for the preset based on its tags, main and additional. If you find it there, then maybe consider adding search terms so that other people won't have to do the same. If not \u2014 write the JSON file according to the schema and using other files for reference, and submit a pull request.</p> <p>You will see the update in Every Door after the request is merged, and a new editor release is published. In the meantime, you could also make a local preset for yourself.</p>"},{"location":"develop/presets/#fields","title":"Fields","text":"<p>Every input field and button you see on the object editing page is defined in some field, referenced from a preset. Usually, barring very few special cases hard-coded in Every Door, a field edits a single key value. Like for this backrest=* field, usually all you need for a field is that key, a label, and a type.</p> <p></p> <p>If there is something wrong with a field, you can find it by locating the preset it is in, reading the <code>fields</code> or <code>moreFields</code> list, and locating the field JSON source in the repository. Often you would do this to add translatable options to a combo field.</p> <p>Before adding a new field that a preset requires, confirm it is indeed absent. Not all fields are listed: sometimes people just forget that e.g. <code>capacity=*</code> fits not only bicycle racks, but also benches. Note that there can be multiple fields for a single key, when the context differs. For <code>capacity</code>, there are three, technically differing only by labels: parking spaces, countable capacity, and volume.</p> <p>As mentioned above, a new field might only need three properties:</p> <pre><code>{\n    \"key\": \"tactile_paving\",\n    \"type\": \"check\",\n    \"label\": \"Tactile Paving\"\n}\n</code></pre> <p>Read the schema definition to learn where to put the file, and how to choose the <code>type</code>. It's the single most important property with ~30 possible values, defining how the field looks and behaves.</p> <p>Often you might want to add restrictions and details with other properties, e.g. <code>placeholder</code> for text fields, <code>minValue</code> for numbers, <code>strings</code> for combo fields. Those are also listed in the schema.</p> <p>Note that by default, only <code>label</code> and <code>placeholder</code> are translatable. For combo and checkbox fields you might want to make options translatable too by listing the most common ones in the strings property.</p> <p>As with presets, Every Door will see your change only after it's been merged and included in the published build. And you can also define a field in your own plugin.</p>"},{"location":"develop/presets/#name-suggestion-index","title":"Name Suggestion Index","text":"<p>When you map a KFC or a Shell fuel station, you would add many tags that are common to other KFC or Shell objects not only in your country, but in the whole world. Like the name, brand, wikipedia and wikidata links, cuisine, fuel types etc. And you might make typos in the process. To avoid this redundant work, the Name Suggestion Index was created to catalogue tagging for common franchises and brands, both local and global.</p> <p>At the base level, an NSI entry is just a name and a list of tags to put on an object. And maybe some terms to make searching easier. In Every Door, you search for a brand, get a gray tile with it, tap it, and get an editor pane with all tags pre-filled. Entries also include an area where the brand is active, <code>\"001\"</code> meaning the entire world. It commonly looks like this:</p> <pre><code>{\n  \"displayName\": \"Frasers\",\n  \"id\": \"frasers-3fbcc0\",\n  \"locationSet\": {\"include\": [\"na\", \"za\"]},\n  \"tags\": {\n    \"brand\": \"Frasers\",\n    \"brand:wikidata\": \"Q116740926\",\n    \"name\": \"Frasers\",\n    \"shop\": \"bag\"\n  }\n}\n</code></pre> <p>To contribute to NSI, you must know the project structure and the meaning of properties. They are documented on the wiki: see the Overview, Category Files for the schema, and a guide on Adding missing entities.</p> <p>Locally, you can have an NSI preset in a plugin. For that, simply omit the <code>fields</code> list. Note that NSI presets do not participate in type detection, so you will see \"Post Box\" in the micromapping legend for any post box, even a branded one that has an NSI entry for it.</p>"},{"location":"develop/presets/#personal-presets","title":"Personal Presets","text":"<p>Some presets are not meant to go into iD or other public instances: they are too local, too focused on the task. For example, when you have a town-wide project to map the state of waste baskets, adding many auxillary tags. Or a proposal is not yet accepted, so there is low chance of your pull request being merged to the global tagging.</p> <p>You can have personal presets in Every Door, and even share them with other people. That would be a part of a plugin. Read on adding presets to plugins.</p>"},{"location":"develop/structure/","title":"Code Navigation","text":"<p>The directory structure has been devised many years ago when the author has been learning Flutter development, so it's not the most effective, but it works. This page walks you through it, so you understand what goes where.</p>"},{"location":"develop/structure/#root","title":"Root","text":"<ul> <li><code>android</code>: Android build files go here. Of most importance are <code>app/build.gradle</code>     and <code>app/src/main/AndroidManifest.xml</code>. If you don't know why, please stay away from those.<ul> <li>Built apk and aab files are put into <code>android/app/prod/release</code>.</li> <li>Note that published apk's on Github use Ilya's personal certificate,     while all beta apk's, including those published to Releases,     are built with a secret certificate for Actions.</li> </ul> </li> <li><code>ios</code>: iOS build files. In XCode, you open <code>Runner.xcworkspace</code>.<ul> <li>Built distribution package is put into <code>build/ios/archive/Runner.xcarchive</code>.     Open it with XCode to upload it to AppStore.</li> </ul> </li> <li><code>assets</code>: files that are packaged with the app. Mostly presets and images.<ul> <li>The production version of presets is uploaded to Textual.</li> </ul> </li> <li><code>vendor</code>: here are git submodules for building. Currently just Flutter SDK.</li> <li><code>metadata</code>: text files for F-Droid, translated on Weblate.     Might be good to go full Fastlane.</li> <li><code>tools</code>: scripts in Python, Dart, and Bash to process data for the editor.</li> <li><code>test</code>: yup, tests. Currently mostly unit tests for algorithmic helpers.</li> <li><code>lib</code>: code.</li> <li><code>pubspec.yaml</code>: The most important file for a Dart project, lists dependencies and stuff.</li> </ul>"},{"location":"develop/structure/#tools","title":"Tools","text":"<ul> <li><code>common_hours.py</code>: the opening hours panel offers common starting and endind times.     This script find those in the TagInfo database.</li> <li><code>encode_url.dart</code>: encodes URLs with keys for imagery constants.</li> <li><code>print_common_keys.py</code>: this script prepares the <code>lib/helpers/tags/common_keys.dart</code>,     used in the raw tag editor.</li> <li><code>test_sqlite_tags.py</code>: preset queries are pretty complex (see <code>lib/providers/presets.dart</code>),     so this script was used to test those.</li> </ul>"},{"location":"develop/structure/#language-codes","title":"Language Codes","text":"<ul> <li><code>language_names.py</code>: I've extracted the table from     this Wikipedia page     to a CSV (<code>language_codes.csv</code>), and extracted language names and ISO codes to a Dart constant.</li> <li><code>match_country_langs.py</code>: this script build a reference table for languages in each     country. The Unicode CLDR data might have been better, but this one uses     Organic Maps data.</li> </ul>"},{"location":"develop/structure/#building-the-database","title":"Building the Database","text":"<p>In short, run <code>update.sh</code> passing it a path to <code>taginfo-db.db</code> and wait. It does five things:</p> <ol> <li>Creates a Python virtual environment to run other scripts.</li> <li>Runs <code>json_to_sqlite.py</code>: it downloads or reads distribution files from     two repositories, Tagging Schema     and NSI,     and repackages the info into an SQLite database. All preset processing,     translations, and search indices are built there.</li> <li>Runs <code>add_taginfo.py</code>. It requests keys for combo fields from this     SQLite database, then runs queries on the TagInfo database (which is     very big, so the queries are slow) to get the most popular values     for those keys, and store them into presets.</li> <li>Runs <code>add_imagery.py</code>. It stores the JSON data from the     Layer Index     repository in the SQLite database almost 1:1. Coverage polygons are     converted into a geohash lookup table.</li> <li>Packages NSI polygon collection into a constant string inside the code.</li> </ol>"},{"location":"develop/structure/#lib","title":"Lib","text":"<ul> <li><code>main.dart</code>: the main executable file for the app. Contains the <code>MaterialApp</code>     with necessary wrappers. Logging, colors, and Let's Encrypt certificate     are all set up here.</li> <li><code>constants.dart</code>: all the constants for various parts of the app. Including     the app title and version, and API endpoints.</li> <li><code>l10n</code>: localization <code>arb</code> files, translated with Weblate. The <code>app_en.arb</code>     is the source and the only one you should edit.<ul> <li>During the build phase, those are compiled into <code>lib/generated</code>.</li> </ul> </li> </ul> <p>There is also <code>commit_info.g.dart</code> generated into the <code>lib</code> root with the commit_info package.</p>"},{"location":"develop/structure/#models-and-controllers","title":"Models and Controllers","text":"<ul> <li><code>models</code>: classes that are passed between the parts. The most important one     is in <code>amenity.dart</code> with the POI definition. Everything editable is     an <code>OsmChange</code>. Also note <code>field.dart</code> with two long functions to     create a field from a preset record.</li> <li><code>helpers</code>: non-visual functions and classes, and sometimes dictionaries.     Most algorithmic stuff goes here, and into providers too. Frankly it's     a mess, there's even a provider in there (<code>legend.dart</code>).<ul> <li><code>geometry</code>: geometric and geodetic functions, e.g. distance calculation,     or snapping points to lines.</li> <li><code>tags</code>: everything related to tags and tag filtering. Some of it is     described here.</li> </ul> </li> <li><code>providers</code>: all the Riverpod providers. They     basically keep an application-wide state, and often are used for a     pure storage (tied to an app context). Some providers (like <code>uploader.dart</code>)     do not have a state, but link multiple providers together for convenience.</li> </ul>"},{"location":"develop/structure/#views","title":"Views","text":"<ul> <li><code>screens</code>: all the panes from the app. The app starts with the <code>loading.dart</code>,     then switches to <code>browser.dart</code>, which displays the current mode page.<ul> <li><code>modes</code>: mode pages that rely on corresponding <code>definitions</code>. The idea     being, you can override a definition to create or modify a mode.     There are four base modes, plus <code>navigate.dart</code> when you zoom out     too far.</li> <li><code>editor</code>: panes and sheets used not only from the editor pane, but     also from modes. E.g. <code>building</code> and <code>entrance</code> are displayed when     you tap a button in the entrances mode. They all edit an <code>OsmChange</code>     or display information related to it.</li> <li><code>settings</code>: all the panes accessible from the Settings menu.</li> </ul> </li> <li><code>widgets</code>: building blocks for the app: buttons, markers, info blocks,     forms. The biggest thing is <code>map.dart</code> with a universal map widget.</li> <li><code>fields</code>: classes inheriting <code>PresetField</code> that implement editors for     various field types. Custom fields should go here.<ul> <li><code>hours</code>: the opening hours editor is the most complex in the app,     and all its parts are here.</li> <li><code>helpers</code>: helpers and panes that some fields open, e.g. a direction     chooser with a map.</li> </ul> </li> </ul>"},{"location":"develop/structure/#data","title":"Data","text":"<p>Not exactly about the code, but the important thing to understand is, where the data is stored. In the app, it is distributed among four sources:</p> <ol> <li>Android secure storage and shared preferences. Mostly for settings and tokens.     For example, switches state from the Settings panel is stored there.</li> <li>Presets SQLite database. It is packaged with the app and is read-only. It is     accessed solely through <code>PresetProvider</code>.</li> <li>App SQLite database. Mostly for downloaded OSM data, but also for location-dependent     indices and settings, e.g. payment tags. See the <code>DatabaseHelper</code> for the schema     and access.</li> <li>Transient in-memory storage, in virtually every provider. Mostly caches.</li> </ol>"},{"location":"develop/translate/","title":"Translating Every Door","text":"<p>OpenStreetMap is used and created in virtually every country of the world by people of hundreds languages. While we abstract the data model in Every Door to make editing more accessible, we cannot abstract words. Thus, we need your help with translating every word in the editor to your own language.</p>"},{"location":"develop/translate/#user-interface","title":"User Interface","text":"<p>The app is translated at Weblate, just like Go Map, MapComplete, and Organic Maps. All those projects will benefit from your knowledge of this translation website.</p> <p>Usually people open the Weblate page, then choose their language (there is an option to add one if it's missing, and you won't need an approval), and start translating strings one by one in the order suggested by the website.</p>"},{"location":"develop/translate/#weblate","title":"Weblate","text":"<p>Let's have a quick look at the translation panel. \"Acquiring location\" are the first words people see when opening Every Door, so it's a good candidate for a showcase.</p> <p></p> <p>Here we're translating to Esperanto, and you can see the string is already there. Above it is English: it is the source, reference language, and it has a string key coming from the app, and a description in white-on-black. This description helps understand where this string is displayed in the app. Russian and Estonian are my secondary languages, which I have enabled in preferences.</p> <p>If you have no idea how to translate the string, click \"Skip\" or press \"Ctrl+\u2193\" (\u2318\u2193 on Mac) to show the next one. Otherwise simply type the translated text and press \"Ctrl+Enter\" (\u2318+Return) to move to the next line. It might help to look at comments and translation history below the form.</p> <p>You can find the complete documentation on translating with Weblate on their website.</p>"},{"location":"develop/translate/#parameters","title":"Parameters","text":"<p>Some strings contain words in figure brackets, e.g. <code>{count}</code>. Do not translate those! Those are placeholders for values that come from the app. For example, in the line \"by {user} at {datetime}\", the <code>{user}</code> part will be replaced with a user name, and <code>{datetime}</code> \u2014\u00a0with a date. If you translate words inside brackets, that would be an error preventing the app from compiling.</p> <p>Plurals are even more tricky. Some lines need to have different translations based on a number: e.g. \"1 year\", but \"2 years\". Conside this:</p> <pre><code>{count,plural, =1{{count} year} few{{count} years} other{{count} years}}\n</code></pre> <p>Here you should translate only \"year(s)\", but not <code>count,plural</code>, <code>few</code>, <code>other</code>, and not <code>{count}</code>. So in Ukrainian, it becomes:</p> <pre><code>{count,plural, =1{{count} \u0440\u0456\u043a} few{{count} \u0440\u043e\u043a\u0438} other{{count} \u0440\u043e\u043a\u0456\u0432}}\n</code></pre> <p>Please be wary of these cases when translating.</p>"},{"location":"develop/translate/#process","title":"Process","text":"<p>You can search for specific strings and translate just a section of the app. For example, all items in the Settings panel naturally have keys that start with <code>settings</code>, and string keys for the opening hours editor start with <code>fieldHours</code>. However I would advise translating everything in whatever order: some days or weeks later you will have dealt with each of ~350 strings and the order won't matter.</p> <p>Additionally there is a Metadata component: there you can translate short and long descriptions, and a change log, into your language for F-Droid store listings. Later it might be employed for other stores as well.</p> <p>Translation services are offered to Every Door by Weblate for free, and we're grateful for that.</p>"},{"location":"develop/translate/#presets-and-fields","title":"Presets and Fields","text":"<p>The editor uses presets from iD: they are managed in a dedicated repository and translated on Transifex. To translate, open the link, login if needed, choose your language and hit \"Translate\". If you need a specific preset or a field, note the \"Key\" in the string context panel, and search for something like <code>key:living_street</code> or <code>key:wheelchair</code>. Also note the \"Developer Notes\" hint to the right.</p> <p>If you have suddenly learned there is no preset or field to translate, see how to add those.</p> <p>Translating options for combo fields is tricky. First, you need to make sure those are known. Find the field in the repository and check the <code>strings/options</code> map. It should look like here. If it is missing all or some options you think are required, please submit a pull request there and wait until it is merged.</p> <p>Then, when the translation source on Transifex is updated, there will be strings to translate. Search for <code>key:fields.&lt;path&gt;</code>, e.g. key:fields.camera/type for <code>data/fields/camera/type.json</code>. You can see both the label and the options there, ready for translating.</p> <p>Presets from the Name Suggestion Index are considered local and are not translated.</p>"},{"location":"develop/translate/#plugins","title":"Plugins","text":"<p>Currently plugins can only be translated by their authors. You can manually download one though, unpack it, and prepare a YAML file with a translation into your language. Later it will be automated with the plugin repository, which will enable plugin translations via Weblate.</p> <p>See the plugin translation section for the file format.</p>"},{"location":"develop/translate/#documentation","title":"Documentation","text":"<p>This website is made with MkDocs and hosted on Github, so it is easy to edit the contents. The Material theme also supports switching languages. But alas it is pretty hard to set up when you don't have a paid subscription. If you know how to do that, please submit a pull request. We would of course like to make this documentation translatable.</p>"},{"location":"guide/","title":"User's Guide","text":""},{"location":"guide/faq/","title":"Frequently Asked Questions","text":""},{"location":"guide/faq/#why-the-map-is-so-tiny","title":"Why the map is so tiny?","text":"<p>Because it's not the point. You only check your positioning on the map, and pan it to adjust. Watch the amenity list below, sorted by distance from you.</p> <p>The map gets bigger when you edit amenities far from your location. Although the app was made to edit things you see with your eyes.</p>"},{"location":"guide/faq/#what-are-the-checkmarks-for","title":"What are the checkmarks for?","text":"<p>These are marks that amenity data was confirmed. They add the <code>check_date</code> tag with the current date.</p> <p>The idea behind the checkmarks is that, say, you surveyed half the city the first time. Then after a month you came back and went to survey again. You need to somehow mark that you see the amenity, but nothing has changed about it. That's the checkmark: you tap it and continue.</p> <p>The mark stays checked for two weeks. After that you may survey the amenities again.</p>"},{"location":"guide/faq/#how-to-add-a-building-entrance","title":"How to add a building entrance?","text":"<p>At the top right there's a button for switching editing modes. It changes modes between amenities, micromapping, and entrances.</p> <p>In the entrance mode, tap or drag the door button in the bottom right corner onto the map.</p>"},{"location":"guide/faq/#can-i-type-letters-into-an-apartment-number","title":"Can I type letters into an apartment number?","text":"<p>If your numeric keyboard cannot be switched to a full one, check the app settings. They are behind the button at the top left corner. Switch on the \"extended numeric keyboard\" there.</p>"},{"location":"guide/faq/#are-floors-3-and-3-the-same","title":"Are floors \"3\" and \"/3\" the same?","text":"<p>No. The first one has <code>addr:floor=3</code> tag filled. That's the floor as it is printed on navigation and commonly used. The second one does not have this tag, but has <code>level=3</code>. That number is a sequential floor number from zero to <code>building:levels - 1</code>. That is, in a three-storey building <code>addr:floor</code> value depends on a country, but <code>level</code> is always 0, 1, or 2.</p> <p>Here is how the notation in the editor related to these tags:</p> <ul> <li><code>2</code>: <code>addr:floor=2</code> and non-empty <code>level=*</code>.</li> <li><code>4/</code>: <code>addr:floor=4</code>, but there's no <code>level</code> tag.</li> <li><code>/1</code>: <code>level=1</code>, but there's no <code>addr:floor</code> tag.</li> <li><code>1/0</code>: <code>addr:floor=1</code> + <code>level=0</code> (and there's an object nearby   with the same <code>addr:floor</code>, but different <code>level</code>, or vice-versa).</li> </ul>"},{"location":"guide/faq/#how-to-undo-an-edit","title":"How to undo an edit?","text":"<p>In the changes list available from Settings, just swipe the item to the left.</p>"},{"location":"guide/faq/#how-to-change-an-amenity-type","title":"How to change an amenity type?","text":"<p>Tap on the editor title, where the type is written.</p>"},{"location":"guide/faq/#all-tagging-questions","title":"All tagging questions","text":"<p>Why an object is missing in the editor? When these white dots are displayed in the micromapping mode? How objects are sorted?</p> <p>Answers to all these questions are in element_kind_std.dart. Here's what you can look at:</p> <ul> <li>Which objects are downloaded \u2014\u00a0class <code>_EverythingKind</code>.</li> <li>What is considered an amenity \u2014\u00a0class <code>_AmenityKind</code>.</li> <li>When a micromapping object is incomplete \u2014\u00a0class <code>_NeedsMoreInfo</code>.</li> <li>Which points are snapped to what ways \u2014\u00a0function <code>detectSnap</code> in snap_tags.dart.</li> <li>The key order for the main tag \u2014 list <code>kMainKeys</code> in main_keys.dart.</li> </ul>"},{"location":"guide/faq/#how-to-change-or-translate-preset-fields","title":"How to change or translate preset fields?","text":"<p>The editor relies on iD editor presets. To modify these, submit a pull request to this repo.</p> <p>The presets are translated at Transifex.</p> <p>To translate value options, first make a pull request to the repo adding desired options, like here. Then, when the translation source on Transifex is updated, there will be strings to translate. Like here.</p>"},{"location":"guide/preface/","title":"Surveying for OpenStreetMap","text":"<p>To use Every Door efficiently and understand its design choices, you must first learn what OpenStreetMap is, how data for it is collected, and why the app was created in the first place. For that, we start with a bit of background.</p>"},{"location":"guide/preface/#openstreetmap-basics","title":"OpenStreetMap Basics","text":"<p>You must know this already: OSM has a very simple data model, which consists of tags, nodes, ways, and relations. Every entity can contain some number of any previous entities: nodes have tags, ways have tags and nodes, and so on. Also only nodes have any geometry, and areas can be represented as closed ways or multipolygon relations.</p> <p>The model simplicity leads to utter complexity of both editing the data and using it. Loading it into a conventional data store means downloading an extract and processing it with Osmium in some form. Clicking through a geometry is simple \u2014 but choosing a correct tag is a pain. What suits better, <code>natural=wood</code> or <code>landuse=forest</code>? Don't answer, it's a running joke.</p> <p>In most editors the latter problem is circumvented with presets: a huge mapping of real-world entities to OSM tags, each with a list of attribute tags. It makes decisions simpler, but still does not solve all the issues: for example, an object can be multiple things at once in OSM (like a fence and a school ground), or have no meaning without a secondary tag (<code>amenity=recycling</code> comes to mind).</p>"},{"location":"guide/preface/#points-of-interest","title":"Points of Interest","text":"<p>All those issues become more apparent when you are adding a shop or a waste basket. I'd recommend watching this talk on the subject. To summarize it:</p> <ul> <li>Venues can be represented with points and polygons. Sometimes both.</li> <li>Finding a correct tag is often hard. There are many duplicates and nuances.</li> <li>Some shops have multiple types, while OSM allows for one.</li> <li>Even seemingly straightforward attributes can have subjective values.</li> <li>Addresses go on everything, not standardized, and often missing.</li> <li>Coverage is patchy, freshness unknown, mapping is hard.</li> </ul> <p>In general, points of interest are the hardest thing to map, because there are no good third-party sources. You have to go around and collect the data yourself. And when you're back, you can spend hours on adding objects to the map, and the result will be indistinguishable from before. Truly, tracing roads and forests is much more gratifying \u2014 albeit possible to automate.</p> <p>That's one reason mapping points of interest is important to OpenStreetMap, and why this app in particular appeared. Another, there hasn't been any good ways to keep the map fresh and collect data at speed.</p>"},{"location":"guide/preface/#sourcing-the-data","title":"Sourcing the Data","text":"<p>Every Door comes from a decade of experiments with optimizing data collection. Which is good, because it makes it the best in class, but also bad, because high efficiency means steep learning curve. To understand those decisions, we need to look back.</p>"},{"location":"guide/preface/#before-times","title":"Before Times","text":"<p>We used GPS loggers, pen and paper, and photo cameras. You walk around, take photos or record all the shops or trees you see. When at home, you open JOSM, add a GPX track from your logger, georeference pictures from the camera, put your walking papers nearby, and start adding collected features one by one.</p> <p>If it sounds tedious and super slow, well, it was. But the sense of power it brought made us going.</p> <p>TODO</p>"},{"location":"guide/preface/#apps","title":"Apps","text":"<p>Editing map on a phone rids you of extra work when you get home. You just add everything you see on the go, and then forget about it. Alas, mobile phones have different issues: mainly, from the small screen size and imprecise controls.</p> <p>TODO</p>"},{"location":"guide/preface/#unsolved-problems","title":"Unsolved Problems","text":""},{"location":"guide/quick_start/","title":"Quick Start","text":"<p>Every Door is closer to JOSM than to StreetComplete, MapComplete or iD. In this editor, you download data, edit it without connecting to the net, and regularly upload changes back to OpenStreetMap.</p>"},{"location":"guide/releases/6.0/","title":"Every Door 6.0","text":"<p>Released on 26 June 2025</p> <p>This release is focused on one thing people (and the author too) have been waiting since 2022:</p>"},{"location":"guide/releases/6.0/#plugins","title":"Plugins","text":"<p>What is a plugin? The lines between configuration files, plugins, extensions, and DLC are very thin. People have asked for more configurability, and for custom builds for specific use cases. Every Door is very opinionated, and hence is not as much configurable as some would prefer. Well, it got more open now, with the introduction of plugins.</p> <p>At the first stage, a plugin is a YAML file in an archive, directing which tags to use, how things look, and what editing modes there are. While not very flexible, it allows for custom imagery, custom presets and fields, and entire custom workflows, for which you might have needed dedicated apps.</p> <p>For example, the prototype mapping pie dispencer makes it easy to download mapping area boundaries to Every Door, to know where to map. In the future it could advise on imagery layers, show a surveying manual, and even track the completion and share locations with other participants.</p> <p>Plugins are collected in the Repository. It is accessible right from the app: go to Settings \u2192 Plugins \u2192 (+) button. Uploading plugins is easy: you only need an OpenStreetMap account. But there are also other ways of installing plugins, e.g. from a QR code.</p> <p>See the Plugins section to learn how to use and how to develop those.</p>"},{"location":"guide/releases/6.0/#amenity-editing","title":"Amenity Editing","text":""},{"location":"guide/releases/6.0/#green-markers","title":"Green Markers","text":"<p>After you have done the initial survey, the re-surveying often consists of a single step: tapping the checkmark, confirming shops are still there. \"Yup, yup, still there, this one too, and this one...\" The idea was, you look at the tiles below the map and ignore the map. But when something's off, like a shop missing, cross-referencing the legend with the map becomes hard.</p> <p>So in this release, I tried to color confirmed amenities green. And it made surveying faster and more fun!</p>"},{"location":"guide/releases/6.0/#dragging-the-button","title":"Dragging the Button","text":"<p>Did you know that in the entrances and notes modes, you could not only tap (+) buttons, but also drag them onto the map? That would save you a second, which is important when you're in a car, for example, collecting all the addresses in a village.</p> <p>Now the code has been restructured for the plugins, and this dragging behaviour has also been added to the first two modes. Try dragging the button next time you add a bench!</p>"},{"location":"guide/releases/6.0/#weekdays","title":"Weekdays","text":"<p>Dmitry from Israel pointed out that the day order (and translations for weekdays) were off. Turns out, in some countries days start not from Monday, and some have a different set of weekends! Now Every Door knows of local rules, and adjusts the opening hours panel accordingly.</p>"},{"location":"guide/releases/6.0/#fixme-objects","title":"Fixme Objects","text":"<p>When you cannot find a correct type for a shop, you could type something free-form into the search field, and tap on the red box to create a special kind of amenity, <code>amenity=fixme</code>. It would record all the data, so that later somebody could find the correct type and retag the object, keeping the name, opening hours, phone numbers etc.</p> <p>Alas the second step rarely happened, and mappers were complaining. To fix that, Every Door will now convert such fixme amenity to an OSM note, in case nothing but the name is provided. It will also highlight fixme amenities marking them as objects to improve.</p> <p>As for other objects with non-empty fixme values, which have been highlighted, it is now easier to clear the <code>fixme</code> tag with a single tap. Thanks to Soham Dixit, who has implemented the feature.</p>"},{"location":"guide/releases/6.0/#wrong-state","title":"Wrong State","text":"<p>Want to change the type of a shop? It's easy: tap the title in the header. Presets specify which tags need to be removed and which to add. Alas, the app forgot to remove the tags first, which resulted in some weird tagging after a type switch. Not anymore.</p> <p>Did not know you could change the object type? I have underlined the title to make it more discoverable.</p> <p>Note that when changing a type, now you won't get a full list of type suggestions. This also is a result from restructuring the code, but feels to be a correct way to go: I've never found a correct replacement in those lists, because they were made for initial surveying, not map gardening.</p> <p>See a shop closed, but with a sign still there? Mark it disused by tapping the orange button in the editor. It would add the <code>disused:</code> prefix to its main tag, producing e.g. <code>disused:shop=clothes</code>. Alas with the advancements to our tagging, and having multiple competing tagging schemas, sometimes one prefix was not enough. In this release, Every Door correctly manages prefixes for hospitals tagged with both <code>amenity=hospital</code> and <code>healthcare=hospital</code>.</p>"},{"location":"guide/releases/6.0/#other","title":"Other","text":""},{"location":"guide/releases/6.0/#compass","title":"Compass","text":"<p>Finally you can know where you are looking! Thanks to Siarhei Fedartsou, the location marker has got a direction triangle.</p>"},{"location":"guide/releases/6.0/#profile","title":"Profile","text":"<p>And Soham Dixit has improved the look of the OSM profile page. Nothing new has been added there though, it's already perfect.</p> <p>Note that due to a library update, you might need to re-login. In some cases, even reinstall the app, although I don't expect that to happen.</p>"},{"location":"guide/releases/6.0/#buildings","title":"Buildings","text":"<p>Turns out \"Cancel\" buttons for buildings and entrances kept the changes. That was very wrong and I have no idea how nobody caught it in three years.</p> <p>Mxdanger has also updated roof shape images appearing in a building editor form. Turns out they have made much more icons than we have seen!</p>"},{"location":"guide/releases/6.0/#translations","title":"Translations","text":"<p>First, mappers in Serbia should have an easier time adding local names, because thanks to Alnzrv, cyrillic and latin alphabets are now properly split between <code>name:sr</code> and <code>name:sr-Latn</code>, which both appear by default when you edit an amenity.</p> <p>Also thanks to Yurt Page, app metadata, namely the description and changelogs, can be translated. Those are used only for F-Droid for now, but in the future someday I might add a Fastlane tool to use those translations when uploading to other stores.</p> <p>Finally, this release has added multiple strings, mostly related to plugins, so I'm grateful to everyone who's translated those into their own languages. Special thanks goes to Mandeep and Kim Kats for vastly improving Punjabi and Greek localizations.</p>"},{"location":"guide/releases/6.0/#system-changes","title":"System Changes","text":"<p>Every Door 6.0 now supports only Android 6 (\"Marshmallow\") or newer. Sorry to those two users on 5.1 who's been left behind. Vespucci has still got you covered. But really, it's over ten years old, and you can easily find newer phones for a few bucks, or even free.</p> <p>We also have a new QR code scanner. The previous one depended on proprietary MLKit, not available on de-googled phones or in the F-Droid build. Now the app uses an alternative open-source library that depends on ZXing for Android and MTBBarcodescanner for iOS. Alas both libraries are in maintenance mode, but they work good enough, at least the Android one. If you encounter any problems scanning QR codes, please report them.</p>"},{"location":"guide/releases/6.0/#new-website","title":"New Website","text":"<p>This website has been migrated to Material for MkDocs, and its sections are gradually filling in. We have a guide on plugins and on contributing in general. User's guide and video tutorials to follow this Summer.</p>"},{"location":"guide/releases/6.0/#thanks-to-nlnet","title":"Thanks to NLNet","text":"<p>This release and the huge code restructuring and development work that went into it were funded through the NGI0 Commons Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 101135429. Additional funding is made available by the Swiss State Secretariat for Education, Research and Innovation (SERI).</p>"},{"location":"guide/releases/7.0/","title":"Every Door 7.0","text":"<p>Released on 24 September 2025</p> <p>The main thing in this release is...</p>"},{"location":"guide/releases/7.0/#imagery-improvements","title":"Imagery Improvements","text":""},{"location":"guide/releases/7.0/#vector-tiles","title":"Vector Tiles","text":"<p>To be fair, Every Door does not need vector map tiles. Its base mode of operation is, you look at amenities around you and find those in the list. Same way, other modes often work better with a satellite imagery.</p> <p>Except when you have no imagery. Or are inside a building, and mapping shops while staring at a roof is not fun. Or the GPS is failing, and you have to find your location manually. There can be many reasons why people resort to using [obsolete] OSM tiles while mapping, dealing with discrepancy between what's on the server, and what's on the phone. The main reason I was keeping in mind was offline work.</p> <p>For a rectangular area roughly 1\u00d71 km you would need to pre-download ~1400 tiles, amounting to ~40 megabytes for a city. Same would take only 200 kilobytes with a vector tile, of which you would need just one (at zoom 14). Which is 200 times less data and thousand times less load on the server.</p> <p>This enables Every Door to work offline by pre-downloading tiles: each vector tile covers an 1\u00d71 km area, which means, you need very few of them to map even a big rural area. And tile downloading limits won't pose an issue.</p> <p>Alas at the last moment I've decided to not make vector tiles the default. Since the MapLibre package is not yet of production quality, the app uses a slower library, and in both rendering options it provides, rendering was too slow, and had some weird artifacts. So to enable vector tiles, please open the plugins pane, and install the Vector Base Map plugin. You can enable and disable it at any time, the cache and the plugin stay on your phone and available offline.</p>"},{"location":"guide/releases/7.0/#predictable-caching","title":"Predictable Caching","text":"<p>Another thing enabling offline work, is that you can know exactly when the cache is cleared, and download tiles for an area at will.</p> <p></p> <p>The new data management panel includes the old button for clearing the downloaded OSM data, but also adds multiple buttons for monitoring and clearing tile caches, for raster and vector tiles separately.</p> <p>Tap the \"Download Tiles\" button to open a map, on which you can select up to 20 rectangles (equal to zoom 15 tiles, ~0.2\u20131 km\u00b2), and bulk download OSM data, base map tiles, and satellite imagery tiles for those. Obviously data and vector tiles cover all the zoom levels, while raster tiles are downloaded up to zoom 18 (which makes it 85 tiles downloaded for each selected rectangle).</p> <p>Everything downloaded stays in a separate cache, so even when you pan and zoom the map too much, nothing explicitly requested will be silently deleted, like it happens with the regular tile cache.</p> <p>Note: the bottom button for downloading tiles might be hidden by the phone UI on Android. This will be fixed in the 7.1 update soon.</p>"},{"location":"guide/releases/7.0/#compass-button","title":"Compass Button","text":"<p>Many people have asked for a button to reset the map rotation. Previously you have to long-press on the location button for that. Which was very obscure. Now we get a special compass button that both shows the rotation angle, and makes it zero when tapped.</p>"},{"location":"guide/releases/7.0/#building-contours","title":"Building Contours","text":"<p>Having vector tiles helped fix one issue with adding entrances to buildings. To make them snap to correct location, you need to drag them as close to the building contour as possible. But with a satellite layer enabled, you have no idea where the contour in OSM is.</p> <p>Now when adding an entrance, you can see white outlines for every building on the screen. Those may have some artifacts on tile lines, but generally you can rely on those.</p> <p>The outlines are not added on the separate map panel that appears when you tap a button in the buildings mode. There you can switch a layer at will. It is only drawn on the map, so that when you drag a button onto the map, you see where you are dragging it to.</p>"},{"location":"guide/releases/7.0/#other-things","title":"Other Things","text":""},{"location":"guide/releases/7.0/#preset-icons","title":"Preset Icons","text":"<p>The amazing iD Tagging Schema repository has an icon associated with most of the presets, and you must have seen the iD editor displaying those. Now you can enjoy the icons in Every Door!</p> <p>Obviously this works for plugins too, so you can have custom icons for your custom presets.</p>"},{"location":"guide/releases/7.0/#tap-to-undo","title":"Tap To Undo","text":"<p>Finally instead of video I can just put a static image here. When you experiment with the editing, and need to revert some changes, it was not obvious how to do that. The \"Pending Changes\" panel had a tiny hint at the bottom, but few people have noticed it. Now I've decided to get rid of type icons, and instead add proper \"delete\" buttons to every change.</p> <p>Don't be afraid to delete a change accidentally: after you do, a panel appears giving you a change to restore the change.</p>"},{"location":"guide/releases/7.0/#thanks-to-nlnet","title":"Thanks to NLNet","text":"<p>This release was once again funded through the NGI0 Commons Fund, a fund established by NLnet with financial support from the European Commission's Next Generation Internet programme, under the aegis of DG Communications Networks, Content and Technology under grant agreement No 101135429. Additional funding is made available by the Swiss State Secretariat for Education, Research and Innovation (SERI).</p>"},{"location":"plugins/","title":"Every Door Plugins","text":"<p>Since version 6.0, the editor can be extended, thanks to the NGI0 grant. You can add new modes, new imagery, replace presets and communicate with third-party API.</p> <p>A plugin is a zip-archive with an <code>edp</code> extension, which includes a <code>plugin.yaml</code> file inside at the top level. All other files are optional.</p> <p>These sections explain how to use and write plugins:</p> <ul> <li>Installation</li> <li>Metadata</li> <li>Code</li> <li>Publishing</li> </ul>"},{"location":"plugins/install/","title":"Installation","text":"<p>Plugins are not meant to sit on your computer and do nothing. How to load them onto your phone, and make them available to thousands of Every Door users (if you want that)?</p> <p>You have four options for that.</p> <ol> <li> <p>Share an <code>.edp</code> file. For example, send it to yourself with a messenger, and     open it on a device. This way you don't have to publish it, and you can     iterate on the development quickly. One issue is, it might not work on iOS.</p> </li> <li> <p>Upload it to the public repository. It would     validate the package on upload, reserve a plugin identifier, and make it available     in the app. Just go to \"Settings \u2192 Plugins \u2192 (+) button\" and find it there.     You only need an OpenStreetMap account to publish plugins. Initially you can     mark your plugin \"experimental\", so it won't appear in public lists.</p> </li> <li> <p>Upload it somewhere open, like to Github or your own web server. This option works     best for programmatically built plugins, e.g. for mapping party settings.     The file name should be equal to the plugin identifier.     To share it, create a QR code with the link to the file, and scan it with the     phone from the \"Settings \u2192\u00a0Plugins \u2192\u00a0(+) \u2192 the button at the top right\".</p> </li> <li> <p>If some of your devices do not support reading QR codes, or you're publishing     plugins on a website intended to be used from a phone, then construct a plugin     installation link. It looks like this:</p> <p><code>https://plugins.every-door.app/i/plugin_id?url=https%3A%2F%2Fexample.com%2F...%2Fplugin_id.edp</code></p> <p>The <code>plugin_id</code> in the base url should match the file name and the identifier from <code>plugin.yaml</code>, but it would also match against the plugin repository list. You can use <code>my</code> instead, like <code>/i/my?...</code>.</p> <p>The link can also have query parameters: <code>version</code> to versionize plugins (useful when you update a published plugin), <code>update=true</code> to force an update even when a newer version of the plugin has been installed.</p> </li> </ol>"},{"location":"plugins/install/#troubleshooting","title":"Troubleshooting","text":"<p>If the installation fails, check the system log: press the button on screen, or find those in \"Settings \u2192 About \u2192\u00a0System Log\".</p> <p>To delete a plugin, open it in the settings panel, and tap \"Delete\".</p>"},{"location":"plugins/publish/","title":"Publishing a Plugin","text":"<p>We have a central repository for Every Door plugins: plugins.every-door.app.</p>"},{"location":"plugins/code/","title":"Plugin Code","text":"<p>Every Door will support compiled Dart code for overriding or extending functions. This section will be documented when we have an API.</p>"},{"location":"plugins/metadata/","title":"Plugin Metadata","text":"<p>A plugin is a zip-archive with an <code>edp</code> extension, which includes a <code>plugin.yaml</code> file inside at the top level. This section explains how to write it.</p> <p>The <code>plugin.yaml</code> file is a simple key-value dictionary in YAML format. There are some top-level keys, like a plugin name, and sections relating to various configurable subsystems.</p> <p>Top level keys are:</p> <ul> <li><code>id</code>: the plugin identifier. Should be different from other identifiers (otherwise this plugin     would replace another with the same id), and consist of latin characters, numbers, dashes,     and underscores. This is the only required key.</li> <li><code>name</code>: plugin name. Can be translated (see below).</li> <li><code>version</code>: numeric version (see below).</li> <li><code>api</code>: supported API versions: either a list of two versions (minimum and maximum, exclusive):     e.g. <code>[1.1, 3.0]</code> supports 2.1, but doesn't support 3.0; or a single version, in which case     the next major version won't be supported.</li> <li><code>description</code>: long-form description of what this plugin does. Split paragraphs with double newlines.</li> <li><code>author</code>: who wrote the plugin.</li> <li><code>icon</code>: an icon for the plugin (see below).</li> <li><code>experimental</code>: <code>true</code> if the plugin should be hidden from the repository lists, <code>false</code> otherwise.</li> <li><code>homepage</code>: a link to GitHub or another website to read about the plugin.</li> <li><code>source</code>: a link to download the recent version of the plugin.</li> <li><code>intro</code>: a text that will be shown after installing the plugin (not when installing from a file),     and also available from the plugin page. Can contain any markdown, including images and links.</li> </ul> <p>While only the <code>id</code> key is required, it's best to provide as many values as possible, at least for the first four: including <code>name</code>, <code>version</code>, and <code>description</code>. Here's for an example:</p> <pre><code>id: cycling_infra\nname: Cycling Infrastructure\nversion: 2\nauthor: Ilya Zverev\nicon: cycling.svg\ndescription: |\n  Testing plugin that adds a new mode to the editor, related to bicycle infrastructure.\n\n  It resembles the building mode, but the primary (right) button adds a cycling barrier,\n  and the secondary adds a bicycle parking stand. For the latter, capacity is shown\n  on the map.\nexperimental: false\n</code></pre>"},{"location":"plugins/metadata/#versioning-plugins","title":"Versioning Plugins","text":"<p>Plugin versions internally are all positive numbers, so it is perfectly valid to use a through enumeration: <code>1</code>, <code>2</code>, and so on.</p> <p>On the other hand, people are used to splitting major and minor releases, to differentiate between big improvements and bug fixes. With that, you can use that scheme for versioning, in the form of <code>&lt;major&gt;.&lt;minor&gt;</code>. For example, <code>0.1</code>, <code>1.0</code>, <code>1.1</code>, and so on.</p> <p>Internally those versions are converted into a single number by multiplying the major version by a thousand, and adding a thousand. So <code>0.1</code> becomes <code>1001</code>, and <code>2.0</code> \u2014 <code>3000</code>. This also means that after version <code>999</code> your plugin might suddenly gain version <code>0.0</code>: that would probably be a good time to switch to <code>1000.0</code>.</p>"},{"location":"plugins/metadata/#icons","title":"Icons","text":"<p>Some sections expect an <code>icon</code> key. The value should be a file name of an image packaged with the plugin, in the <code>icons</code> subdirectory. For example, if you specify <code>icon: cycling.svg</code>, then the editor would look for <code>icons/cycling.svg</code> file in the plugin archive.</p> <p>Formats supported are SVG, PNG, GIF, and WebP. Good sources for SVG icons are Material Icons, and Maki. See this list for additional sources.</p> <p>Note that to make an SVG file re-colorable, you would need to add an attribute to either its elements, or to the <code>&lt;svg&gt;</code> outer tag: <code>stroke=\"currentColor\"</code> and/or <code>fill=\"currentColor\"</code>. This \"current color\" is what will be replaced with the icon color value.</p> <p>Raster images are converted to black-and-white on its transparency layer, and the color is set to all non-transparent pixels.</p> <p>Another option for fast prototyping is to use an emoji character for an icon. Two drawbacks of that are, emoji are not recolorable, and the alignment is slighly off. To use a character, find one in Emojipedia, switch to the \"Techinical information\" tab, and copy the codepoint sequence in form of <code>U+1F525</code> to the icon value.</p>"},{"location":"plugins/metadata/#translations","title":"Translations","text":"<p>You can provide labels in many languages for a plugin. To add a translation into a language, create a top-level directory in the plugin package named <code>langs</code>, and inside it, files named with language codes, e.g. <code>es.yaml</code>, <code>pt-BR.yaml</code>.</p> <p>Each file should have the same structure as the <code>plugin.yaml</code>, but keeping just keys that need translation. Those usually are <code>name</code>, <code>label</code>, <code>labels</code>, <code>placeholder</code> etc. Some keys contain lists of strings instead of single string values, e.g. <code>labels</code> for preset fields. Translate them as usual, keeping the list in order.</p>"},{"location":"plugins/metadata/#imagery","title":"Imagery","text":"<p>Read the imagery section when you want to:</p> <ul> <li>Add a new base or overlay raster tile or WMS layer.</li> <li>Include a GeoJSON file and display it in the app.</li> <li>Package an MBTiles raster tile database with the plugin.</li> </ul>"},{"location":"plugins/metadata/#element-kinds","title":"Element Kinds","text":"<p>Read the element kinds section to:</p> <ul> <li>Add support for non-amenity tags, e.g. indoor or parking.</li> <li>Understand why some objects are not displayed.</li> <li>Define tag groups for some editing modes.</li> </ul>"},{"location":"plugins/metadata/#modes","title":"Modes","text":"<p>Read the modes section to:</p> <ul> <li>Customize colors and markers in the micromapping mode.</li> <li>Update the default preset lists.</li> <li>Create a custom entrances-like mode for dropping objects on the map.</li> </ul>"},{"location":"plugins/metadata/#presets-and-fields","title":"Presets and Fields","text":"<p>Read the presets section to:</p> <ul> <li>Add a custom preset that shouldn't go into the global presets repository.</li> <li>Add a custom field and employ it in some presets.</li> <li>Define fields for a new entrances-like mode.</li> </ul>"},{"location":"plugins/metadata/element_kinds/","title":"Element Kinds","text":"<p>An \"element kind\" is a set of rules that apply to tags to split objects into groups. Before the refactoring, some groups were made to non-intersect, but that can be untrue now. Each element kind has a string name, and a set of tag matching rules.</p> <p>We have multiple pre-defined element kinds:</p> <ul> <li><code>amenity</code>: objects that are editable in the \"Amenity\" mode. Usually they have opening hours, and deliver some services. Almost always it's for money. Shops, offices, parcel points, ATMs go here.</li> <li><code>needsCheck</code>: default to the <code>amenity</code> kind, indicates if the object benefits from regular assessment. Manifests as a checkmark in the POI editor mode.</li> <li><code>structure</code>: a subset of amenities that usually exist for decades or centuries once built. Examples are schools, churches, and stadiums.</li> <li><code>micro</code>: objects in the micromapping mode. Defined as \"not amenity\", and with a list of allowed keys.</li> <li><code>needsInfo</code>: lists of important missing tags for micromapping-related objects.</li> <li><code>building</code>: basically <code>building=*</code>, except for <code>building=entrance</code>.</li> <li><code>entrance</code>: basically <code>entrance=*</code> or <code>building=entrance</code>.</li> <li><code>address</code>: an address node. It should have no other use (no \"main tag\"), and either <code>addr:housenumber</code> or <code>addr:housename</code>.</li> <li><code>everything</code>: every key-value combination by which objects are filtered from the downloaded OSM extract. A rule of thumb is, no linear feature tags, and no polygons that are usually too big to grasp from being there.</li> <li><code>empty</code>: no meaningful tags except <code>source</code> and <code>note</code>.</li> <li><code>unknown</code>: a nothing-kind that's returned when an object does not match other kinds.</li> </ul>"},{"location":"plugins/metadata/element_kinds/#main-key","title":"Main Key","text":"<p>Before everything else, we need to clarify what \"main key\" means. Every Door works on an assumption that every object in OSM data represents one separate entity. This is not always correct (e.g. shops on buildings, or fences and school areas), but mostly checks out: it is exceptionally rare to find a <code>shop</code> and <code>amenity</code> on a single POI object.</p> <p>To detect the main key, Every Door iterates over a list of keys, taking the first one found. So for a polygon with <code>amenity=school</code> and <code>barrier=fence</code>, it would choose the first one. It does consider lifecycle prefixes, so changing <code>shop</code> to <code>disused:shop</code> changes nothing with regard to the main key.</p> <p>It is not possible to extend the main key list through a plugin, you would need to submit a pull request.</p> <p>Now, some standard element kinds apply only to the main tag (key and value). Those are <code>amenity</code>, <code>needsCheck</code>, <code>structure</code>, <code>micro</code>, and <code>everything</code>. Others either don't care for an object type (like <code>empty</code>), or acknowledge an object can be multiple things at once (like <code>building</code>).</p>"},{"location":"plugins/metadata/element_kinds/#defining-kinds","title":"Defining Kinds","text":"<p>A simple <code>ElementKind</code> looks like this:</p> <pre><code>kinds:\n  cycleBarrier:\n    matcher:\n      barrier:\n        only: [cycle_barrier]\n</code></pre> <p>The <code>cycleBarrier</code> element kind matches only a single tag, <code>barrier=cycle_barrier</code>, and only as a main key. If an object has more important defining tag, like <code>amenity=post_box</code>, the matcher won't pick up the barrier tag.</p> <p>To look for matches in every tag, you can set <code>onMainKey: false</code> for the element kind definition. As mentioned earlier, it is rarely needed, so you must know what you're doing.</p> <p>The only other thing in a kind is a tag matcher. It is defined in the <code>matcher</code> key when we're defining a new element kind, or completely replacing an existing one. For updating an existing element kind, e.g. for adding a support for a new tag, use instead the <code>update</code> key:</p> <pre><code>kinds:\n  everything:\n    update:\n      amenity:\n        replace: true\n        except:\n          - parking\n          - parking_entrance\n          - loading_dock\n          - waste_dump_site\n          - waste_transfer_station\n</code></pre> <p>You might think, this looks exactly like the current definition of the <code>amenity</code> tag handling, but here we skipped the <code>parking_space</code> value, allowing for editing its properties.</p> <p>Note that the editor won't touch linear features, so there is no point in enabling, for example, <code>waterway=river</code> or <code>highway=residential</code>.</p>"},{"location":"plugins/metadata/element_kinds/#matchers","title":"Matchers","text":"<p>A tag matcher (the one you specify for an element kind) looks at tag keys, like <code>amenity</code> or <code>man_made</code>. It's the first layer of testing: if a key is not in its dictionary, it fails the check.</p> <p>The definition for a matcher is a map with tag keys for keys, and matching rules for values. Those matching rules can have those keys:</p> <ul> <li><code>only</code>: a list of values that can match. If it's not empty, all other values or an absence of the key would fail the check.</li> <li><code>except</code>: a list of forbidden values. The check will fail if the tag is present, and its value is in this list.</li> <li><code>when</code>: a map of \"value: tag matcher\". It invokes a nested matcher when the tag has the given value. It allows for testing secondary tags, e.g. <code>recycling_type=*</code> for <code>amenity=recycling</code>.</li> <li><code>replace</code>: when redefining a matcher, this boolean flag (<code>true</code> by default) controls whether we're replacing all the rules, or updating the lists. Matchers in <code>when</code> get replaced in any case. Note that you cannot remove entries from <code>only</code> and <code>except</code>, only append to the lists. To remove, just copy a list without some entries, like we did above in the <code>amenity=parking_space</code> example.</li> </ul>"},{"location":"plugins/metadata/element_kinds/#matching-on-the-main-key","title":"Matching on the Main Key","text":"<p>If an element kind containing tag matcher works on main keys, the matcher can automatically accept an object when certain keys are present. A list of those keys goes into <code>$good</code> attribute. It looks like this:</p> <pre><code>kinds:\n  amenityKind:\n    matcher:\n      \"$good\":\n        - shop\n        - craft\n        - office\n        - healthcare\n        - club\n      amenity:\n        except: [parking, ...]\n        when:\n          recycling:\n            recycling_type:\n              only: [centre]\n</code></pre> <p>This example illustrates both keys that are considered amenities for every possible values, and a conditional <code>amenity=recycling</code> handling.</p>"},{"location":"plugins/metadata/element_kinds/#missing-tags","title":"Missing Tags","text":"<p>There is also a <code>$missing</code> tag matcher list, which behaves weirdly. It passes only when at least one of the listed keys are missing. That is, if we have <code>\"$missing\": [leaf_type, leaf_cycle]</code>, then the matched will pass only when the object does not have at least one of those two tags.</p> <p>Only one element kind uses the <code>$missing</code> list, and it's <code>needsInfo</code>. The micromapping mode uses it to display a white dot on objects that miss some important information. You can add that indication to new types of objects (based on their main key) using this example of how it's done for bus stops and pedestrian crossings:</p> <pre><code>kinds:\n  needsInfo:\n    matcher:\n      highway:\n        crossing:\n          when:\n            \"$missing\": [crossing]\n        bus_stop:\n          when:\n            \"$missing\":\n              - bench\n              - shelter\n</code></pre>"},{"location":"plugins/metadata/imagery/","title":"Custom Imagery","text":"<p>Adding extra imagery layers is simple. In the <code>imagery</code> section, specify imagery layers as a map of maps:</p> <pre><code>imagery:\n  IPR-orotofoto-last-tms:\n    name: \"Praha IPR latest orthophoto\"\n    url: \"https://osm-{switch:a,b,c}.zby.cz/tiles_ipr_last.php/{zoom}/{x}/{y}.jpg\"\n    maxZoom: 20\n    attribution: \"IPR Praha; OSM CZ\"\n  turkuOrto:\n    name: \"City of Turku ortophoto\"\n    type: wms\n    url: \"https://opaskartta.turku.fi/TeklaOGCWeb/WMS.ashx?FORMAT=image/png&amp;TRANSPARENT=TRUE&amp;VERSION=1.1.1&amp;SERVICE=WMS&amp;REQUEST=GetMap&amp;LAYERS=Ilmakuva 2021&amp;STYLES=&amp;SRS={proj}&amp;WIDTH={width}&amp;HEIGHT={height}&amp;BBOX={bbox}\"\n    minZoom: 4\n    maxZoom: 20\n    attribution: \"\u00a9 Turun kaupunki\"\n  nommeTest:\n    url: nomme-test.mbtiles\n    maxZoom: 18\n</code></pre> <p>Available keys are:</p> <ul> <li><code>url</code>: the only required key, layer URL templated the same as in the editor layer index.</li> <li><code>name</code>: how the layer is listed on the imagery panel.</li> <li><code>type</code>: one of those:<ul> <li><code>tms</code>: a regular tile service with URLs usually ending in <code>/{zoom}/{x}/{y}.png</code></li> <li><code>wms</code>: a WMS service, like the <code>turkuOrto</code> in the example. This type is implied when the URL contains <code>SERVICE=WMS</code>.</li> <li><code>mbtiles</code>: a packaged MBTiles file. This type is implied when the url (which should point to the file) ends with <code>.mbtiles</code>. Only raster tile packages are supported. A web URL would probably fail.</li> <li><code>vector</code>: a vector imagery layer, see below.</li> </ul> </li> <li><code>icon</code>: an icon to show on the imagery panel.</li> <li><code>attribution</code>: the string displayed on the screen when the layer is active.</li> <li><code>minZoom</code> and <code>maxZoom</code>: self-explanatory, integer numbers.</li> <li><code>wms4326</code>: a boolean field that should be true for WMS layers which support EPSG:4326, but not 3857.</li> <li><code>tileSize</code>: for TMS layers, defaults to 256.</li> <li><code>opacity</code>: layer opacity, between 0.0 and 1.0 (since API 1.1). Not all layer types support this. It is possible to have semi-transparent base tiles, and it would look weird.</li> <li><code>headers</code>: HTTP headers to add when requesting tiles.</li> <li><code>force</code>: when set to <code>true</code>, forces this imagery to be enabled when the plugin is installed, and on every app restart.</li> </ul> <p>To change the base map layer, use <code>base</code> for an imagery key. For example:</p> <pre><code>imagery:\n  base:\n    name: \"Topo Map\"\n    url: ...\n</code></pre>"},{"location":"plugins/metadata/imagery/#overlays","title":"Overlays","text":"<p>Initially Every Door displays a single map layer: either OpenStreetMap-based for the base map, or an imagery layer. For thematic or directed mapping you might need to add more layers: for example, a semi-transparent tile layer with a heatmap, or display polygons for an area to confine the mapping effort.</p> <p>With plugins, it's pretty simple: add an <code>overlays</code> key with a list of layers in the same format.</p> <pre><code>overlays:  \n\u00a0- url: \"https://tile.waymarkedtrails.org/cycling/{zoom}/{x}/{y}.png\"  \n\u00a0\u00a0\u00a0maxZoom: 17  \n\u00a0- url: map.geojson\n</code></pre> <p>With overlays, you can also use a <code>geojson</code> type. It is automatically inferred when the URL ends with a <code>.geojson</code> or a <code>.json</code>. URLs are supported, but if the <code>url</code> value does not start with <code>http</code>, it is assumed to be a file inside the plugin.</p>"},{"location":"plugins/metadata/imagery/#vector-tiles","title":"Vector Tiles","text":"<p>Since API 1.1</p> <p>You can reference vector tiles, and even package them, saving on space compared to raster tiles. Those are added like regular imagery (anywhere: as a base layer, overlay, or even satellite), and require at least two keys:</p> <ul> <li><code>type: vector</code> is required.</li> <li><code>url</code>: name of the style JSON file, either an URL or a file name inside the plugin.</li> <li><code>name</code>, <code>icon</code>, <code>attribution</code>, <code>headers</code>: same as for raster layers.</li> <li><code>key</code>: API key, should be referenced in style URLs as <code>{key}</code>.</li> <li><code>fast</code>: if <code>true</code> (default), tiles are rendered into raster tiles, if <code>false</code> \u2014 they are     re-rendered all the time, allowing for labels to be rotated, for example. As the name     implies, non-fast mode is slow when there is a lot to draw.</li> </ul> <p>Here is an example adding two layers: one external for the base layer, and one packaged overlay:</p> <pre><code>imagery:\n  base:\n    name: Positron\n    url: https://tiles.openfreemap.org/styles/positron\n    type: vector\n    attribution: OpenFreeMap\n\noverlays:\n  - url: tallinn-overlay.json\n    type: vector\n</code></pre> <p>A style can reference both external and packaged tiles (as MBTiles). Sprites can also be packaged. Glyphs are not supported. Here is a sample style for the overlay mentioned above:</p> <pre><code>{\n  \"id\": \"tallinn-overlay\",\n  \"sources\": {\n    \"mbtiles\": {\n      \"type\": \"vector\",\n      \"tiles\": [\"greater_tallinn.mbtiles\"],\n      \"minzoom\": 1,\n      \"maxzoom\": 14\n    }\n  },\n  \"sprite\": \"sprite\",\n  \"layers\": [...]\n}\n</code></pre> <p>It references <code>greater_tallinn.mbtiles</code>, <code>sprite.json</code>, and <code>sprite.png</code> packaged into the root of the plugin archive.</p>"},{"location":"plugins/metadata/modes/","title":"Overriding Modes","text":"<p>Modes are listed in the <code>modes</code> entry as maps: keys are mode identifiers, and values are maps of key-value mode settings.</p> <p>There are four mode types which are also the names of the four pre-defined modes: <code>micro</code>, <code>amenity</code>, <code>entrances</code>, <code>notes</code>. When your mode identifier is one of those, it doesn't add a new mode, but alters parameters of an existing mode.</p> <p>You can hide an existing mode by adding <code>hide: true</code> option. Like this:</p> <pre><code>modes:\n  entrances:\n    hide: true\n  notes:\n    hide: true\n</code></pre> <p>For a new mode, you should specify <code>icon</code> and <code>iconActive</code> with a mode icon. The second one is optional.</p> <p>Note that not all parameters that you specify for a new mode can be adjusted for an existing mode.</p>"},{"location":"plugins/metadata/modes/#micromapping","title":"Micromapping","text":"<p>Things you can adjust:</p> <ul> <li><code>kinds</code> (or <code>kind</code>, a string or a list of strings): objects that are edited in this mode. <code>micro</code> by default.</li> <li><code>otherKinds</code> (or <code>otherKind</code>): objects that are shown as black dots on the map. <code>amenity</code> by default.</li> <li><code>defaultPresets</code> (a list of strings): preset names for the list appearing after you tap the (+) button.</li> <li><code>markers</code>: a map of preset name \u2192 marker definition, for overriding colors and icons in the legend and on the map. The definition can be either a <code>icon: icon_name</code> (see above), or a <code>color: color_name</code>.<ul> <li>We use this library to resolve color names. Also several <code>ed</code>-prefixed colors are available, for those pre-built into the micromapping mode. For example, <code>edRed</code> and <code>edTeal</code>.</li> </ul> </li> <li><code>iconsInLegend</code>: when assigning an icon to a preset, it might be obvious from its appearance on the map. So when you do it at scale, the legend might become redundant. Setting this flag to <code>false</code> removes iconized items from the legend.</li> </ul>"},{"location":"plugins/metadata/modes/#amenity","title":"Amenity","text":"<p>This mode is technically similar to the micromapping mode, hence some settings are similar:</p> <ul> <li><code>kinds</code> (or <code>kind</code>, a string or a list of strings): objects that are edited in this mode. <code>amenity</code> by default.</li> <li><code>otherKinds</code> (or <code>otherKind</code>): objects that are shown as black dots on the map. <code>micro</code> by default (yes, the opposite of the Micromapping set up).</li> <li><code>defaultPresets</code> (a list of strings): preset names for the list appearing after you tap the (+) button.</li> </ul> <p>But there are new ones:</p> <ul> <li><code>checkIntervals</code>: a mapping of day intervals for various element kinds: how often one could return and confirm the amenity by pressing a \u2713 checkmark in the tile. By default it has two entries: <code>structure: 360</code> and <code>amenity: 60</code>. The latter is a catch-all, it's not exactly matched against the <code>amenity</code> kind.</li> </ul> <p>Currently you cannot create new instances of this mode.</p>"},{"location":"plugins/metadata/modes/#entrances","title":"Entrances","text":"<p>This mode can be duplicated. Actually, it cannot be modified at the moment, since there are no replaceable attributes, so copying is the only mode of operation.</p> <p>Fields for a new mode:</p> <ul> <li><code>kinds</code>: list of element kinds this mode supports.</li> <li><code>primary</code>: a mapping for setting up the primary type button (bottom right for the right-hand operation):<ul> <li><code>preset</code>: a preset name that's the editor is open with.</li> <li><code>icon</code>: what's drawn on the button.</li> <li><code>tooltip</code>: a tooltip for the icon.</li> <li><code>adjustZoom</code>: if different from 0.0, when you start dragging the button onto the map, it temporarily changes zoom level inwards. For example, the default entrances button has this set to 0.7.</li> </ul> </li> <li><code>secondary</code>: the same for the second button.</li> <li><code>markers</code>: a mapping for element kind \u2192 representation definition. Each one can have those keys:<ul> <li><code>requiredKeys</code>: list of tag keys that need to be non-empty in order for the object to be considered fully surveyed. For example, a tree could have <code>[leaf_type, leaf_cycle]</code>.</li> <li><code>icon</code>: whether to draw an icon here. Add <code>iconPartial</code> to notice missing keys.</li> <li><code>label</code>: a template to print on the marker, e.g. <code>{capacity}</code> for bicycle parking. Keys should be enclosed in figure quotes.</li> <li>If nothing is specified, a round marker would be used, filled yellow for \"complete\" and white otherwise.</li> </ul> </li> </ul>"},{"location":"plugins/metadata/modes/#notes","title":"Notes","text":"<p>Currently cannot be customized much, and because of this, cannot be duplicated. You can only change one property of the <code>notes</code> mode:</p> <ul> <li><code>locked</code>: whether the drawing is locked when you open the mode screen. Note that it changes the state at the moment of plugin loading, but does not persist when the app is active. Hence it affects only the initial state when the app is open.</li> </ul>"},{"location":"plugins/metadata/presets/","title":"Presets","text":"<p>Every Door allows for adding and redefining presets and fields. By presets, we mean a set of tags that define an object, and a set of fields that appear in its editor panels. And fields are items on those panels, like input fields or choice buttons.</p>"},{"location":"plugins/metadata/presets/#presets","title":"Presets","text":"<p>All presets go under the <code>presets</code> key in the <code>plugin.yaml</code> file, as \"id\u2192definition\" maps. It's worth looking at the iD preset schema documentation to understand the structure. Here's an example:</p> <pre><code>presets:\n  taaraautomaat:\n    name: \"Taaraautomaat\"\n    terms: [pr\u00fcgi]\n    icon: taara.svg\n    tags:\n      amenity: vending_machine\n      vending: bottle_return\n    addTags:\n      name: Taaraautomaat\n      amenity: vending_machine\n      vending: bottle_return\n      \"recycling:cans\": yes\n      \"recycling:glass_bottles\": yes\n      \"recycling:plastic_bottles\": yes\n      \"recycling:refund_bottles\": yes\n    area: true\n    fields:\n      - roofShape\n      - '@amenity/vending_machine/bottle_return'\n</code></pre> <p>Here it defines a preset with an identifier <code>taaraautomaat</code> (not present in the packaged database). What do the keys mean:</p> <ul> <li><code>name</code>: a string label for the preset, displayed in the app bar of the editor panel, and on a tile in the type search panel.</li> <li><code>terms</code>: additional search terms for the preset, so it's easier to find with the autocomplete search.</li> <li><code>icon</code>: an icon to display in the search results tile. Can be an URL.</li> <li><code>area</code>: whether this preset applies to closed polygons as well as points. <code>true</code> is the default.</li> <li><code>tags</code>: a set of tags (as a key-value map) used to identify whether an object is of the given preset. In the example, it would mean that objects having <code>amenity=vending_machine</code> and <code>vending=bottle_return</code> tags will have this preset assigned to them, e.g. the editor will use the fields from this definition.</li> <li><code>addTags</code>: which tags to add when creating the object with this preset. Should include the <code>tags</code> content.</li> <li><code>removeTags</code>: which tags to remove when changing the type of the object to another preset.</li> <li><code>fields</code>: a list of string identifiers of fields to present in an editor. Can include a reference to fields of another preset, starting with \"@\": in the example, it adds a custom field on top of the standard fields of a <code>bottle_return</code> preset. Currently you cannot reference plugin-packaged presets here.</li> <li><code>moreFields</code>: same, but for the initially collapsed extended field list. If omitted, and when <code>fields</code> contain a reference to a preset, it will be populated from the <code>moreFields</code> list of that preset.</li> <li><code>standard</code>: by default, the editor panel constructs a third group of fields, \"standard fields\". Those contain an address and a level for everything, and a name, wheelchair access and other stuff for amenities. For custom forms that could be undesired, so when this key is set to <code>false</code>, fields will be presented as-is.</li> </ul> <p>If the <code>fields</code> list is missing, the preset is considered to be a part of a name suggestion index: it will appear in a differently-colored tile in search results, and will have its fields retrieved from a matching normal preset.</p> <p>Plugin presets take priority over bundled presets, so it is possible to override some of those. For example, this snippet adds a custom <code>benchType</code> field to the bench preset (while losing the translations and custom search terms):</p> <pre><code>  amenity/bench:\n    name: Bench\n    tags:\n      amenity: bench\n    fields:\n      - backrest\n      - armrest\n      - material\n      - benchType\n      - seats\n    moreFields:\n      - '@amenity/bench'\n</code></pre>"},{"location":"plugins/metadata/presets/#fields","title":"Fields","text":"<p>Fields are commonly used in presets, and also share large parts of the schema with iD presets. In a plugin definition they go under a <code>fields</code> key, and just like presets, those are \"id\u2192definition\" maps. Here is how the <code>benchType</code> field from the example above is defined:</p> <pre><code>fields:\n  benchType:\n    label: Bench Type\n    key: 'bench:type'\n    type: combo\n    options:\n      - seated\n      - stand_up\n      - block\n      - lounger\n      - swing\n      - platform\n      - log\n      - canton\n      - circular\n</code></pre> <p>With the preset overridden, it looks like this in the object editor:</p> <p></p> <p>What keys can go in a field definition:</p> <ul> <li><code>key</code>: which tag key does this field edit. Make sure to parenthesize keys with semicolons.</li> <li><code>label</code>: field label, will be displayed alongside it on an editor page.</li> <li><code>placeholder</code>: a faint grey label for text input fields.</li> <li><code>prerequisiteTag</code>: tags that this field depends upon (see here).</li> <li><code>type</code>: field type, which defines how it looks and what tags it affects.</li> </ul> <p>Types are mostly the same as listed in the upstream schema, since the code shares the type resolver. There is one extra type supported for plugins: <code>inlineCombo</code> (can be abbreviated to <code>inline</code>). It is the same as a one-choice <code>combo</code>, but with a fixed limited set of options that are displayed all at once, not trimmed to three items. And when you press a \"custom\" option, it transforms into a text input field instead of opening a separate pane. See fields in the buildings and entrances mode pop-up editors for examples.</p> <p>Combo fields have those keys as well:</p> <ul> <li><code>customValues</code>: whether to allow custom values.</li> <li><code>numeric</code>: whether custom values should be non-negative integer numbers (only applies to inline combos, <code>true</code> by default).</li> <li><code>options</code>: a list of available values, presented as a set of buttons or a pop-up list.</li> <li><code>labels</code>: a list of human-readable labels for each option, in order. For an inline combo, some or all labels can reference icons instead. For example:</li> </ul> <pre><code>fields:\n\u00a0roofShape:  \n\u00a0\u00a0\u00a0label: Roof  \n\u00a0\u00a0\u00a0key: \"roof:shape\"  \n\u00a0\u00a0\u00a0type: inlineCombo  \n\u00a0\u00a0\u00a0customValues: false  \n\u00a0\u00a0\u00a0options:  \n\u00a0\u00a0\u00a0\u00a0\u00a0- flat  \n\u00a0\u00a0\u00a0\u00a0\u00a0- gabled  \n\u00a0\u00a0\u00a0\u00a0\u00a0- hipped  \n\u00a0\u00a0\u00a0\u00a0\u00a0- pyramidal  \n\u00a0\u00a0\u00a0\u00a0\u00a0- skillion  \n\u00a0\u00a0\u00a0\u00a0\u00a0- half-hipped  \n\u00a0\u00a0\u00a0\u00a0\u00a0- round  \n\u00a0\u00a0\u00a0\u00a0\u00a0- gambrel  \n\u00a0\u00a0\u00a0\u00a0\u00a0- mansard  \n\u00a0\u00a0\u00a0labels:  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/flat.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/gabled.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/hipped.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/pyramidal.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/skillion.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/half-hipped.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/round.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/gambrel.png  \n\u00a0\u00a0\u00a0\u00a0\u00a0- roofs/mansard.png\n</code></pre> <p>And it looks like this in an editor:</p> <p></p> <p>Note that while a list of options defines all possible options one can choose in the editor, OSM data can have different values, and those will be displayed as textual labels when a matching icon is not found.</p>"}]}